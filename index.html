<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>B-Captcha</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background: #f0f0f0;
      margin: 40px;
    }
    .captcha-container {
      position: relative;
      width: 100%;
      max-width: 400px;
      margin: 20px auto;
      height: 200px;
    }
    .shape, .slot {
      width: 60px;
      height: 60px;
      font-size: 40px;
      border: 2px dashed #666;
      background: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      position: absolute;
      transition: box-shadow 0.2s;
    }
    .slot.correct { border-color: green; }
    .slot.incorrect { border-color: red; }
    #verifyBtn {
      margin-top: 20px;
      padding: 8px 16px;
    }
    #msg {
      color: red;
      margin-top: 10px;
    }
    #hp-field {
      position: absolute;
      left: -9999px;
      top: auto;
      width: 1px;
      height: 1px;
      overflow: hidden;
    }
    .slot .hint {
      opacity: 0.2;
      font-size: 40px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <h2>B-Captcha</h2>
  <p>Drag each shape into its matching moving slot</p>

  <input type="text" id="hp-field" name="hp-field" autocomplete="off" tabindex="-1" />

  <div class="captcha-container">
    <div id="shapes"></div>
    <div id="slots"></div>
  </div>

  <button id="verifyBtn" disabled>Verify</button>
  <p id="msg"></p>

  <script>
    const shapes = [
      { id: 'circle', emoji: '🟢' },
      { id: 'triangle', emoji: '🔺' },
      { id: 'square', emoji: '🟦' }
    ];

    let matched = {};
    let dragInfo = null;

    const shapesEl = document.getElementById('shapes');
    const slotsEl = document.getElementById('slots');
    const verifyBtn = document.getElementById('verifyBtn');
    const msgEl = document.getElementById('msg');
    const hpField = document.getElementById('hp-field');

    // Create draggable shapes
    const order = [...shapes].sort(() => Math.random() - 0.5);
    order.forEach((s, i) => {
      const el = document.createElement('div');
      el.className = 'shape';
      el.innerText = s.emoji;
      el.draggable = true;
      el.id = `shape-${s.id}`;
      el.style.top = '160px';
      el.style.left = `${50 + i * 100}px`;

      el.addEventListener('dragstart', e => {
        dragInfo = { shapeId: s.id };
        e.dataTransfer.setData('text/plain', s.id);
      });

      shapesEl.appendChild(el);
    });

    // Create moving slots
    const slotConfigs = shapes.map((s, i) => {
      const slot = document.createElement('div');
      slot.className = 'slot';
      slot.dataset.id = s.id;
      slot.innerHTML = `<span class="hint">${s.emoji}</span>`;
      slot.x0 = 100 + (i * 100);
      slot.y0 = 60;
      slot.radius = 40 + Math.random() * 20;
      slot.freq = 0.002 + Math.random() * 0.002;
      slot.phase = Math.random() * Math.PI * 2;

      slot.addEventListener('dragover', e => e.preventDefault());
      slot.addEventListener('drop', onDrop);
      slotsEl.appendChild(slot);
      return slot;
    });

    // Animate slots in circular motion
    function animate(time) {
      slotConfigs.forEach(slot => {
        const angle = time * slot.freq + slot.phase;
        const dx = slot.radius * Math.cos(angle);
        const dy = slot.radius * Math.sin(angle);
        slot.style.left = `${slot.x0 + dx}px`;
        slot.style.top = `${slot.y0 + dy}px`;
      });
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    function onDrop(e) {
      e.preventDefault();
      const slot = e.currentTarget;
      const draggedId = e.dataTransfer.getData('text/plain');

      if (hpField.value) {
        recordFail('Bot detected.');
        return;
      }

      if (draggedId === slot.dataset.id) {
        slot.classList.remove('incorrect');
        slot.classList.add('correct');
        slot.innerText = shapes.find(s => s.id === draggedId).emoji;
        matched[draggedId] = true;
      } else {
        slot.classList.add('incorrect');
        slot.innerText = '❌';
        matched[slot.dataset.id] = false;
        recordFail('Wrong match.');
        return;
      }

      if (shapes.every(s => matched[s.id])) {
        verifyBtn.disabled = false;
        msgEl.textContent = '';
      }
    }

    verifyBtn.addEventListener('click', () => {
      alert('B-Captcha passed!');
    });

    function recordFail(reason) {
      msgEl.textContent = reason + ' Try again.';
    }
  </script>
</body>
</html>
