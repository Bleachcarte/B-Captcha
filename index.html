<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>B-Captcha</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(to bottom, #f4f7f9, #e2e6ea);
      margin: 0;
      padding: 40px 20px;
      text-align: center;
    }

    .captcha-container {
      width: 100%;
      max-width: 420px;
      margin: 0 auto;
    }

    .frame {
      position: relative;
      width: 100%;
      height: 320px;
      background: #fff;
      border: 2px solid #ddd;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    #shapes {
      position: absolute;
      bottom: 15px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-around;
      padding: 10px 5px;
      z-index: 10;
    }

    .shape, .slot {
      width: 60px;
      height: 60px;
      font-size: 36px;
      border: 2px dashed #aaa;
      background: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 14px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.07);
      user-select: none;
      transition: transform 0.2s ease;
      cursor: grab;
    }
    .shape:active {
      cursor: grabbing;
    }

    .slot {
      position: absolute;
      pointer-events: auto;
    }

    .slot.correct {
      border-color: green;
      background: #e0ffe0;
      box-shadow: 0 0 8px green;
    }
    .slot.incorrect {
      border-color: red;
      background: #ffe0e0;
      box-shadow: 0 0 8px red;
    }

    .slot .hint {
      opacity: 0.15;
      pointer-events: none;
      user-select: none;
    }

    #verifyBtn, #continueBtn {
      margin-top: 30px;
      padding: 14px 28px;
      border: none;
      border-radius: 24px;
      font-size: 17px;
      background-color: #007bff;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.2s ease;
      user-select: none;
    }
    #verifyBtn:disabled {
      background-color: #b0c9ff;
      cursor: not-allowed;
    }
    #verifyBtn:hover:not(:disabled),
    #continueBtn:hover {
      background-color: #0056b3;
      transform: scale(1.05);
    }

    #msg {
      color: #b30000;
      margin-top: 14px;
      min-height: 24px;
      font-weight: 600;
      user-select: none;
    }

    #hp-field {
      position: absolute;
      left: -9999px;
      width: 1px;
      height: 1px;
      overflow: hidden;
    }

    #success {
      display: none;
      background: #d4edda;
      padding: 22px 18px;
      border-radius: 16px;
      margin-top: 28px;
      color: #155724;
      font-weight: 700;
      box-shadow: 0 3px 15px rgba(21, 87, 36, 0.25);
      user-select: none;
    }

    /* Tap mode highlight */
    .shape.selected {
      border-color: #007bff;
      box-shadow: 0 0 10px #007bff;
      transform: scale(1.1);
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h2>B-Captcha</h2>
  <p id="instruction">Loading...</p>

  <!-- Honeypot input for bot detection -->
  <input type="text" id="hp-field" name="hp-field" autocomplete="off" tabindex="-1" />

  <div class="captcha-container">
    <div class="frame" id="frame">
      <div id="slots"></div>
      <div id="shapes"></div>
    </div>
  </div>

  <button id="verifyBtn" disabled>Verify</button>
  <p id="msg"></p>

  <div id="success">
    ✅ You’ve been verified!<br />
    <button id="continueBtn">Continue</button>
  </div>

  <script>
    // Shapes data
    const shapes = [
      { id: 'circle', emoji: '🟢' },
      { id: 'triangle', emoji: '🔺' },
      { id: 'square', emoji: '🟦' }
    ];

    // State variables
    let matched = {};
    let dragInfo = null;
    let animationActive = true;
    let selectedShapeId = null;
    let tapMode = false;

    // DOM references
    const shapesEl = document.getElementById('shapes');
    const slotsEl = document.getElementById('slots');
    const frameEl = document.getElementById('frame');
    const verifyBtn = document.getElementById('verifyBtn');
    const msgEl = document.getElementById('msg');
    const hpField = document.getElementById('hp-field');
    const successEl = document.getElementById('success');
    const continueBtn = document.getElementById('continueBtn');
    const instructionEl = document.getElementById('instruction');

    // Detect real drag and drop support
    function supportsRealDragAndDrop() {
      const div = document.createElement('div');
      const draggableSupported = ('draggable' in div);
      const dragEventSupported = ('ondragstart' in div);
      const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      if (draggableSupported && dragEventSupported && !isTouchDevice) {
        return true; // desktop-like drag support
      }
      return false; // fallback to tap mode on touch or limited support
    }

    tapMode = !supportsRealDragAndDrop();

    // Set instruction text dynamically
    if (tapMode) {
      instructionEl.innerHTML = '<strong>Tap</strong> a shape to select it, then <strong>tap</strong> a moving slot to place it.';
    } else {
      instructionEl.innerHTML = '<strong>Hold</strong> and <strong>drag</strong> each shape into its matching moving slot.';
    }

    // Create draggable shapes at the bottom
    const order = [...shapes].sort(() => Math.random() - 0.5);
    order.forEach((s, i) => {
      const el = document.createElement('div');
      el.className = 'shape';
      el.innerText = s.emoji;
      el.id = `shape-${s.id}`;

      if (!tapMode) {
        // Drag and drop events
        el.draggable = true;

        el.addEventListener('dragstart', e => {
          dragInfo = {
            shapeId: s.id,
            startTime: Date.now(),
            moves: []
          };
          e.dataTransfer.setData('text/plain', s.id);
        });

        // Track mouse movements for irregularity check (commented out)
        el.addEventListener('mousemove', e => {
          if (dragInfo) dragInfo.moves.push({ x: e.clientX, y: e.clientY });
        });
      } else {
        // Tap mode: click/touch selects shape
        el.addEventListener('click', () => {
          if (verifyBtn.disabled === false) return; // already verified

          if (selectedShapeId === s.id) {
            // Deselect
            selectedShapeId = null;
            el.classList.remove('selected');
          } else {
            // Deselect any other selected
            document.querySelectorAll('.shape.selected').forEach(x => x.classList.remove('selected'));
            selectedShapeId = s.id;
            el.classList.add('selected');
          }
        });
      }

      shapesEl.appendChild(el);
    });

    // Create moving slots inside the frame
    const slotConfigs = shapes.map(s => {
      const slot = document.createElement('div');
      slot.className = 'slot';
      slot.dataset.id = s.id;
      slot.innerHTML = `<span class="hint">${s.emoji}</span>`;

      // Random start position inside frame boundaries (account for shapes area at bottom)
      slot.x = Math.random() * (frameEl.clientWidth - 60);
      slot.y = Math.random() * (frameEl.clientHeight - 60 - 80) + 20;

      // Velocity px/frame: random speed and direction (between -1.2 and 1.2)
      slot.vx = (Math.random() * 2.4) - 1.2;
      slot.vy = (Math.random() * 2.4) - 1.2;

      // Apply position
      slot.style.left = slot.x + 'px';
      slot.style.top = slot.y + 'px';

      if (!tapMode) {
        // Drag & drop events
        slot.addEventListener('dragover', e => e.preventDefault());
        slot.addEventListener('drop', onDrop);
      } else {
        // Tap mode: tap slot to place selected shape
        slot.addEventListener('click', () => {
          if (!selectedShapeId || verifyBtn.disabled === false) return;

          // Honeypot bot detection
          if (hpField.value) {
            recordFail('Bot detected.');
            return;
          }

          if (selectedShapeId === slot.dataset.id) {
            slot.classList.remove('incorrect');
            slot.classList.add('correct');
            slot.innerText = shapes.find(s => s.id === selectedShapeId).emoji;
            matched[selectedShapeId] = true;
            selectedShapeId = null;
            document.querySelectorAll('.shape.selected').forEach(x => x.classList.remove('selected'));
            msgEl.textContent = '';
          } else {
            slot.classList.add('incorrect');
            slot.innerText = '❌';
            matched[slot.dataset.id] = false;
            recordFail('Wrong match.');
            return;
          }

          // Enable verify button if all matched
          if (shapes.every(s => matched[s.id])) {
            verifyBtn.disabled = false;
            msgEl.textContent = '';
          }
        });
      }

      slotsEl.appendChild(slot);
      return slot;
    });

    // Animation loop: move slots with bouncing inside frame bounds
    function animate() {
      if (!animationActive) return;

      // Update frame size dynamically for responsiveness
      const frameW = frameEl.clientWidth;
      const frameH = frameEl.clientHeight;

      slotConfigs.forEach(slot => {
        slot.x += slot.vx;
        slot.y += slot.vy;

        // Bounce horizontally
        if (slot.x < 0) {
          slot.x = 0;
          slot.vx = -slot.vx;
        } else if (slot.x > frameW - 60) {
          slot.x = frameW - 60;
          slot.vx = -slot.vx;
        }

        // Bounce vertically (avoid bottom 80px for shapes)
        if (slot.y < 0) {
          slot.y = 0;
          slot.vy = -slot.vy;
        } else if (slot.y > frameH - 60 - 80) {
          slot.y = frameH - 60 - 80;
          slot.vy = -slot.vy;
        }

        slot.style.left = slot.x + 'px';
        slot.style.top = slot.y + 'px';
      });

      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // On window resize, reposition slots if out of bounds
    window.addEventListener('resize', () => {
      const frameW = frameEl.clientWidth;
      const frameH = frameEl.clientHeight;

      slotConfigs.forEach(slot => {
        slot.x = Math.min(slot.x, frameW - 60);
        slot.y = Math.min(slot.y, frameH - 60 - 80);
        slot.style.left = slot.x + 'px';
        slot.style.top = slot.y + 'px';
      });
    });

    // Drop handler (drag and drop mode)
    function onDrop(e) {
      e.preventDefault();
      const slot = e.currentTarget;
      const draggedId = e.dataTransfer.getData('text/plain');

      // Honeypot bot detection
      if (hpField.value) {
        recordFail('Bot detected.');
        return;
      }

      const duration = Date.now() - dragInfo.startTime;

if (duration < 150) {
  recordFail('Drag too fast.');
  return;
}
if (duration > 8000) {
  recordFail('Drag too slow.');
  return;
}

// Calculate total distance dragged
const moves = dragInfo.moves;
let totalDistance = 0;
for (let i = 1; i < moves.length; i++) {
  const dx = moves[i].x - moves[i - 1].x;
  const dy = moves[i].y - moves[i - 1].y;
  totalDistance += Math.hypot(dx, dy);
}

if (totalDistance > 2000) {
  recordFail('Drag too erratic.');
  return;
}


      // Check correct match
      if (draggedId === slot.dataset.id) {
        slot.classList.remove('incorrect');
        slot.classList.add('correct');
        slot.innerText = shapes.find(s => s.id === draggedId).emoji;
        matched[draggedId] = true;
      } else {
        slot.classList.add('incorrect');
        slot.innerText = '❌';
        matched[slot.dataset.id] = false;
        recordFail('Wrong match.');
        return;
      }

      // Enable verify button if all matched
      if (shapes.every(s => matched[s.id])) {
        verifyBtn.disabled = false;
        msgEl.textContent = '';
      }
    }

    // Verify button clicked
    verifyBtn.addEventListener('click', () => {
      animationActive = false;
      // Disable all dragging and tapping
      document.querySelectorAll('.shape').forEach(el => el.draggable = false);
      document.querySelectorAll('.shape').forEach(el => el.style.pointerEvents = 'none');
      verifyBtn.style.display = 'none';
      successEl.style.display = 'block';
    });

    // Continue button reloads page (or redirect here later)
    continueBtn.addEventListener('click', () => {
      window.location.reload();
    });

    // Display failure message
    function recordFail(reason) {
      msgEl.textContent = reason + ' Try again.';
    }
  </script>
</body>
</html>
